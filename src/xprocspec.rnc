# XProcSpec = XProc Specifications
# This schema is for XProcSpec documents, which can be used to describe the behaviour
# of XProc steps. They are similar to the XSpec documents used in XSLT
# testing, but for XProc
default namespace = "http://www.daisy.org/ns/pipeline/xproc/test"
datatypes xs = "http://www.w3.org/2001/XMLSchema-datatypes"

start = description

description = 
	## A description is a description of a script. 
	## It must have a script associated with it.
	## It may also have a version to aid development over time.
	element description { 
		common-attributes,
		attribute script { xs:anyURI }?,
		attribute xproc-version { xs:NMTOKEN }?,
		attribute version { xs:NMTOKEN }?,		
		attribute preserve-space { xs:NMTOKENS }?,
		(import | scenario | pending)+ }

import = 
	## An import brings in all the scenarios from the referenced file (which must
	## itself be an XProcSpec description). All the unshared scenarios in that imported
	## XProcSpec will be run on the stylesheet that this XProcSpec document describes.
	## Importing is recursive and may be circular (although only one copy of a given
	## imported document will actually be imported).
	element import { common-attributes, attribute href { xs:anyURI } }

pending = 
	## Anything that is within a <pending> element will remain untested, but will be
	## reported as (eventual) desired behaviour. This is a good way of commenting out
	## a set of behaviours that haven't been implemented yet, or scenarios whose
	## desired behaviour hasn't been determined, or tests for code that you're not
	## currently working on, to make the testing process faster.
	##
	## An optional label attribute can be used to describe why the scenario or
	## assertion should not be tested.
	element pending { common-attributes, label?, (scenario | assertion)* }

scenario = 
	## A scenario defines the environment in which a piece of processing takes place.
	##
	## Any parameters defined within a scenario equate to global (stylesheet)
	## parameters.
	##
	## If a scenario has a pending attribute, this has the same semantics as
	## wrapping the scenario in a <pending> element with a label equal to the value
	## of the pending attribute.
	##
	## If any scenario has a focus attribute, any scenarios without a focus 
	## attribute will be classed as pending.
	element scenario { common-scenario-attributes, shared?,
		label,
		implementation?,
		step-scenario
		}

common-scenario-attributes = common-attributes,
                             attribute pending { text }?,
                             attribute focus { text }?

implementation = attribute implementation { xs:anyURI }

label = 
	## A scenario's label should describe the context that the scenario sets. Top-
	## level scenarios' labels should be of the form "the square of a number" or 
	## "the XHTML for a <P1> element". Nested scenario labels will usually start with 
	## the word "with"; it should make sense if the labels of ancestor scenarios are 
	## concatenated with this one. For example "with a Type attribute".
	attribute label { text } |
	element label { any-content }

shared = 
	## There are shared scenarios (shared="yes") and unshared scenarios (shared="no",
	## the default). Shared scenarios can be referenced and reused by other scenarios
	## with the <like> element. Unshared scenarios are simply run.
	attribute shared { "yes" | "no" }

like = 
	## The <like> element pulls a shared scenario into this one (which may be shared
	## or unshared). Any environment set within the shared scenario is merged with
	## this one, and any tests in the shared scenario are run in addition to the
	## ones in this scenario. This allows for modular, reusable sets of tests which
	## can be applied in multiple contexts.
	element like { common-attributes, label }
                      
## A step scenario is one based on a call to a pipeline. The <call>
## element defines the step call and the inputs, options and parameters passed to it and the
## <assertion> elements test the ports of the pipeline. Child scenarios
## can override the ports, options and parameters in the template call.
step-scenario = step-call?, 
                 like*,
                 (pending | assertion)*,
                 (pending | 
                  element scenario { common-scenario-attributes,
                                     label, step-scenario })*
                   
step-call = 
	## A <call> element defines a step call and the
	## inputs, options and parameters passed to it. 
	element call {
		common-attributes,
		attribute step { xs:QName }?,
		(step-param | step-params | step-option | step-input)*
	}

step-param = element param { common-attributes, name, ns?, as?, selection }
step-params = element params { common-attributes, href }
step-option = element option { common-attributes, name, as?, selection }
step-input = element input { common-attributes, port, selection }

name = attribute name { xs:QName }
port = attribute port { xs:QName }

as = attribute as { text }

ns = attribute ns { xs:anyURI }?

href = attribute href { xs:anyURI }?

selection = node-selection | value-selection

node-selection = attribute href { xs:anyURI }?,
                 attribute select { xpath }?, 
                 document*

value-selection = attribute select { xpath }

document =
    ## Either reference an external document using href, or provide the document inline.
    ## The document can optionally be given a custom base URI using xml:base.
    element document { common-attributes,
                       ( attribute href { xs:anyURI } | any-content)
                     }

xpath = text

assertion = 
	## An assertion's test XPath can either return a boolean value, in which case the 
	## assertion succeeds only if the test is true; or a node, in which case the
	## assertion succeeds only if the node is equal to the one specified with the
	## href and select attributes or content of the <expect> element.
	element expect { common-attributes,
		label, port, ( test | document* ) }

test = attribute test { xpath }

common-attributes = attribute xml:* { text }*

any-content = mixed { any-element* }
any-element = element * { attribute * { text }*, any-content }